<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced IoT Network Monitor</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css"
    />
    <link rel="icon" href="data:," />
    <style>
      :root {
        --primary-color: #0d6efd;
        --success-color: #198754;
        --warning-color: #ffc107;
        --danger-color: #dc3545;
        --info-color: #0dcaf0;
        --dark-color: #212529;
      }

      body {
        background-color: #f8f9fa;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      .navbar {
        background: linear-gradient(135deg, var(--dark-color), #495057);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .chart-container {
        position: relative;
        height: 350px;
        width: 100%;
        margin-bottom: 20px;
      }

      .card {
        margin-bottom: 24px;
        border: none;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transition: all 0.3s ease;
      }

      .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
      }

      .metric-card {
        text-align: center;
        padding: 24px;
        background: linear-gradient(135deg, #fff, #f8f9fa);
      }

      .metric-value {
        font-size: 2.5em;
        font-weight: 700;
        margin-bottom: 8px;
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--info-color)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .metric-label {
        color: #6c757d;
        font-size: 0.95em;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .status-indicator {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .status-online {
        background: linear-gradient(135deg, var(--success-color), #20c997);
        box-shadow: 0 0 8px rgba(25, 135, 84, 0.4);
      }
      .status-warning {
        background: linear-gradient(135deg, var(--warning-color), #ffca2c);
        box-shadow: 0 0 8px rgba(255, 193, 7, 0.4);
      }
      .status-offline {
        background: linear-gradient(135deg, var(--danger-color), #e63946);
        box-shadow: 0 0 8px rgba(220, 53, 69, 0.4);
      }

      .alert-container {
        max-height: 400px;
        overflow-y: auto;
      }

      .alert-item {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        margin-bottom: 8px;
        border-radius: 8px;
        background: white;
        border-left: 4px solid;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
      }

      .alert-item:hover {
        transform: translateX(4px);
      }

      .alert-critical {
        border-left-color: var(--danger-color);
      }
      .alert-warning {
        border-left-color: var(--warning-color);
      }
      .alert-info {
        border-left-color: var(--info-color);
      }

      .node-card {
        border-left: 4px solid var(--primary-color);
        transition: all 0.3s ease;
      }

      .node-card.warning {
        border-left-color: var(--warning-color);
        background: linear-gradient(135deg, #fff, #fffbf0);
      }

      .node-card.danger {
        border-left-color: var(--danger-color);
        background: linear-gradient(135deg, #fff, #fdf2f2);
      }

      .node-card.success {
        border-left-color: var(--success-color);
        background: linear-gradient(135deg, #fff, #f0f9f4);
      }

      .loading-spinner {
        display: none;
        text-align: center;
        padding: 40px;
      }

      .spinner-custom {
        width: 50px;
        height: 50px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .btn-gradient {
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--info-color)
        );
        border: none;
        color: white;
        transition: all 0.3s ease;
      }

      .btn-gradient:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        color: white;
      }

      .table-container {
        max-height: 500px;
        overflow-y: auto;
        border-radius: 8px;
      }

      .table th {
        background: linear-gradient(135deg, var(--dark-color), #495057);
        color: white;
        font-weight: 600;
        border: none;
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .table-row-success {
        background-color: rgba(25, 135, 84, 0.1);
      }
      .table-row-warning {
        background-color: rgba(255, 193, 7, 0.1);
      }
      .table-row-danger {
        background-color: rgba(220, 53, 69, 0.1);
      }

      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1050;
        min-width: 300px;
        max-width: 400px;
      }

      .chart-legend {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin: 0 15px 5px 0;
        font-size: 0.9em;
      }

      .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        margin-right: 6px;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .performance-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 6px;
      }

      .perf-excellent {
        background-color: var(--success-color);
      }
      .perf-good {
        background-color: #28a745;
      }
      .perf-fair {
        background-color: var(--warning-color);
      }
      .perf-poor {
        background-color: var(--danger-color);
      }
      .protocol-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  align-items: center;
  justify-content: flex-start;
}

.protocol-legend .legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
  white-space: nowrap;
}
    </style>
    <script
      src="https://cdn.socket.io/4.6.1/socket.io.min.js"
      integrity="sha384-KA7m0DwgQGmeRC6Xre3hJO+ZxpanOauVh4Czdqbg8lDKJ3bZZYVYmP+y4F31x40L"
      crossorigin="anonymous"
    ></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  </head>
  <body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark">
      <div class="container">
        <a class="navbar-brand" href="/">
          <i class="fas fa-network-wired me-2"></i>
          Enhanced IoT Network Monitor
        </a>
        <div class="navbar-nav ms-auto d-flex align-items-center">
          <div class="me-3">
            <span
              id="connectionStatus"
              class="status-indicator status-offline"
            ></span>
            <span id="connectionText" class="text-light">Connecting...</span>
          </div>
          <div class="me-3">
            <small class="text-light"
              >Last Update: <span id="lastUpdateTime">-</span></small
            >
          </div>
          <button
            class="btn btn-outline-light btn-sm"
            onclick="toggleFullscreen()"
          >
            <i class="fas fa-expand-arrows-alt"></i>
          </button>
        </div>
      </div>
    </nav>

    <div class="container mt-4">
     
      <div class="container-fluid mt-4">
        <!-- Notification Area -->
        <div id="notificationArea"></div>

        <!-- Loading Spinner -->
        <div id="loadingSpinner" class="loading-spinner">
          <div class="spinner-custom"></div>
          <p class="mt-3">Loading network data...</p>
        </div>

        <!-- Alert Panel -->
        <div id="alertPanel" class="row mb-4" style="display: none">
          <div class="col-12">
            <div class="card border-warning">
              <div
                class="card-header bg-warning text-dark d-flex justify-content-between align-items-center"
              >
                <h6 class="mb-0">
                  <i class="fas fa-exclamation-triangle me-2"></i>Active Alerts
                </h6>
                <button
                  class="btn btn-sm btn-outline-dark"
                  onclick="dismissAllAlerts()"
                >
                  Dismiss All
                </button>
              </div>
              <div class="card-body p-3">
                <div id="alertsList" class="alert-container"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Overview Metrics -->
        <div class="stats-grid">
          <div class="card metric-card">
            <div class="metric-value" id="activeNodes">0</div>
            <div class="metric-label">Active Nodes</div>
            <div class="mt-2">
              <small class="text-muted">
                <i class="fas fa-circle text-success me-1"></i>
                <span id="onlineNodes">0</span> Online
                <i class="fas fa-circle text-warning ms-2 me-1"></i>
                <span id="warningNodes">0</span> Warning
              </small>
            </div>
          </div>
          <div class="card metric-card">
            <div class="metric-value text-success" id="avgRssi">0</div>
            <div class="metric-label">Avg Signal Strength</div>
            <div class="mt-2">
              <span id="rssiIndicator" class="performance-indicator"></span>
              <small class="text-muted" id="rssiStatus">Calculating...</small>
            </div>
          </div>
          <div class="card metric-card">
            <div class="metric-value text-info" id="avgLatency">0</div>
            <div class="metric-label">Avg Network Latency</div>
            <div class="mt-2">
              <span id="latencyIndicator" class="performance-indicator"></span>
              <small class="text-muted" id="latencyStatus"
                >Calculating...</small
              >
            </div>
          </div>
          <div class="card metric-card">
            <div class="metric-value text-warning" id="avgPacketLoss">0</div>
            <div class="metric-label">Avg Packet Loss</div>
            <div class="mt-2">
              <span
                id="packetLossIndicator"
                class="performance-indicator"
              ></span>
              <small class="text-muted" id="packetLossStatus"
                >Calculating...</small
              >
            </div>
          </div>
          <div class="card metric-card">
            <div class="metric-value text-primary" id="avgThroughput">0</div>
            <div class="metric-label">Avg Throughput</div>
            <div class="mt-2">
              <span
                id="throughputIndicator"
                class="performance-indicator"
              ></span>
              <small class="text-muted" id="throughputStatus"
                >Calculating...</small
              >
            </div>
          </div>
          <div class="card metric-card">
            <div class="metric-value text-secondary" id="totalMeasurements">
              0
            </div>
            <div class="metric-label">Total Measurements</div>
            <div class="mt-2">
              <small class="text-muted">
                Last
                <span id="currentTimeRange">6</span>
                hour<span id="timeRangePlural">s</span>
              </small>
            </div>
          </div>

          <div class="card metric-card">
            <div class="metric-value text-secondary" id="qosDisplay">-</div>
            <div class="metric-label">QOS</div>
          </div>
        </div>

        <!-- Controls -->
      <div class="row mb-4">
  <!-- Left Panel -->
  <div class="col-md-8">
    <div class="card p-3">
      <div class="d-flex flex-wrap align-items-center gap-3">
        
        <!-- Time Range Dropdown -->
        <div>
          <label for="timeRange" class="form-label mb-1">Time Range:</label>
          <select id="timeRange" class="form-select form-select-sm">
            <option value="10">10 min</option>
            <option value="30">30 min</option>
            <option value="60" selected>1 hour</option>
            <option value="180">3 hours</option>
            <option value="720">12 hours</option>
          </select>
        </div>

        <!-- Auto Refresh -->
        <div>
          <label class="form-label mb-1">Auto Refresh:</label>
          <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" id="autoRefresh" checked>
            <label class="form-check-label" for="autoRefresh">
              <span id="refreshInterval">30s</span>
            </label>
          </div>
        </div>

        <!-- Node Filter -->
        <div>
          <label for="nodeSelector" class="form-label mb-1">Node Filter:</label>
          <select id="nodeSelector" class="form-select form-select-sm">
            <option value="">All Nodes</option>
            <option value="Node1">Node 1</option>
            <option value="Node2">Node 2</option>
            <!-- Add more nodes dynamically as needed -->
          </select>
        </div>

        <!-- Protocol Filter -->
        <div>
          <label for="protocolSelector" class="form-label mb-1">Protocol Filter:</label>
          <select id="protocolSelector" class="form-select form-select-sm">
            <option value="">All Protocols</option>
            <option value="TCP">TCP</option>
            <option value="UDP">UDP</option>
            <option value="HTTP">HTTP</option>
            <option value="MQTT">MQTT</option>
            <option value="SMTP">SMTP</option>
            <option value="ICMP">ICMP</option>
          </select>
        </div>

        <!-- Action Buttons -->
        <div class="w-100 mt-2">
          <button id="updateCharts" class="btn btn-success">
            Update Charts
          </button>
          <button id="clearFilters" class="btn btn-outline-secondary ms-2 ">
            Clear Filters
          </button>
        </div>
<!-- Protocol Legend -->
      <div class="protocol-legend d-flex flex-wrap small p-1" id="protocolLegend">
  <!-- Will be populated dynamically -->
</div>
      </div>
    </div>
  </div>

  <!-- Right Panel -->
  <div class="col-md-4">
    <div class="card p-3">
      <div class="d-flex gap-2">
       <button id="exportData" class="btn btn-sm btn-outline-primary">
                Export CSV
              </button>
        <button class="btn btn-outline-primary btn-sm flex-fill" onclick="generateReport()">
          <i class="fas fa-file-alt me-1"></i> Report
        </button>
        <a href="/optimization" class="btn btn-outline-success btn-sm flex-fill">
          <i class="fas fa-cogs me-1"></i> Optimize
        </a>
      </div>
    </div>
  </div>
</div>

      <!-- 
      <div id="qosPredictionBox" style="margin-top: 20px">
        <h5>Predicted QoS</h5>
        <div id="qosDisplay" class="alert alert-secondary" role="alert">
          Waiting for QoS prediction...
        </div>
        <button onclick="requestQoSPrediction()" class="btn btn-primary btn-sm">
          Request Test QoS
        </button>
      </div>-->

      <!-- Controls Panel -->
      <!-- <div class="controls-panel">
        <div class="row">
          <div class="col-md-4">
            <label for="nodeSelector" class="form-label">Select Nodes:</label>
            <select id="nodeSelector" class="form-select" multiple>
              Options will be populated dynamically -->
            <!-- </select>
            <small class="form-text text-muted"
              >Hold Ctrl/Cmd to select multiple nodes</small
            >
          </div>
          <div class="col-md-4">
            <label for="protocolSelector" class="form-label"
              >Filter by Protocol:</label
            >
            <select id="protocolSelector" class="form-select" multiple>
              <option value="HTTP">HTTP</option>
              <option value="SMTP">SMTP</option>
              <option value="ICMP">ICMP</option>
              <option value="TCP">TCP</option>
              <option value="UDP">UDP</option>
              <option value="MQTT">MQTT</option>
            </select>
            <small class="form-text text-muted"
              >Leave empty to show all protocols</small
            >
          </div>-->
          <!-- <div class="col-md-4">
            <label class="form-label">Time Range:</label>
            <select id="timeRange" class="form-select">
              <option value="10">Last 10 minutes</option>
              <option value="30">Last 30 minutes</option>
              <option value="60" selected>Last 1 hour</option>
              <option value="180">Last 3 hours</option>
              <option value="720">Last 12 hours</option>
            </select>
          </div>
        </div> -->


      <!-- Protocol Legend -->
      <div class="protocol-legend" id="protocolLegend">
        <!-- Will be populated dynamically -->
      </div>

      <div class="row mt-4">
        <div class="col-md-6">
          <div class="card">
            <div
              class="card-header d-flex justify-content-between align-items-center"
            >
              <span>Signal Strength (RSSI)</span>
              <small class="text-muted" id="rssiNodeCount">0 nodes</small>
            </div>
            <div class="card-body">
              <div class="chart-container">
                <canvas id="rssiChart"></canvas>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card">
            <div
              class="card-header d-flex justify-content-between align-items-center"
            >
              <span>Network Latency by Protocol</span>
              <small class="text-muted" id="latencyNodeCount">0 nodes</small>
            </div>
            <div class="card-body">
              <div class="chart-container">
                <canvas id="latencyChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-md-6">
          <div class="card">
            <div
              class="card-header d-flex justify-content-between align-items-center"
            >
              <span>Packet Loss Rate by Protocol</span>
              <small class="text-muted" id="packetLossNodeCount">0 nodes</small>
            </div>
            <div class="card-body">
              <div class="chart-container">
                <canvas id="packetLossChart"></canvas>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card">
            <div
              class="card-header d-flex justify-content-between align-items-center"
            >
              <span>Network Throughput by Protocol</span>
              <small class="text-muted" id="throughputNodeCount">0 nodes</small>
            </div>
            <div class="card-body">
              <div class="chart-container">
                <canvas id="throughputChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Protocol Statistics -->
      <div class="row mt-4">
        <div class="col-12">
          <div class="card">
            <div class="card-header">Protocol Performance Summary</div>
            <div class="card-body">
              <div class="row" id="protocolStats">
                <!-- Will be populated dynamically -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="row mt-4">
        <div class="col-12">
          <div class="card">
            <div
              class="card-header d-flex justify-content-between align-items-center"
            >
              <span>Live Network Data</span>
              <!-- <button id="exportData" class="btn btn-sm btn-outline-primary">
                Export CSV
              </button> -->
            </div>
            <div class="card-body">
              <div class="table-responsive">
                <table class="table table-striped table-hover">
                  <thead>
                    <tr>
                      <th>Node ID</th>
                      <th>Protocol</th>
                      <th>RSSI (dBm)</th>
                      <th>Channel</th>
                      <th>Latency (ms)</th>
                      <th>Packet Loss</th>
                      <th>Throughput (KB/s)</th>
                      <th>Time</th>
                    </tr>
                  </thead>
                  <tbody id="dataTable">
                    <!-- Data will be inserted here -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let socket;
      let charts = {};
      let nodes = {};
      let allData = [];
      const maxPoints = 50;

      // Protocol colors
      const protocolColors = {
        HTTP: "#FF6384",
        SMTP: "#36A2EB",
        ICMP: "#FFCE56",
        TCP: "#4BC0C0",
        UDP: "#9966FF",
        MQTT: "#FF9F40",
      };

      // Node colors (fallback for when protocol color is not available)
      const nodeColors = [
        "#FF6384",
        "#36A2EB",
        "#FFCE56",
        "#4BC0C0",
        "#9966FF",
        "#FF9F40",
        "#FF6B6B",
        "#4ECDC4",
      ];

      function initializeCharts() {
        if (typeof Chart === "undefined") {
          console.error("Chart.js not loaded properly");
          return;
        }

        // RSSI Chart
        charts.rssi = new Chart(
          document.getElementById("rssiChart").getContext("2d"),
          {
            type: "line",
            data: { labels: [], datasets: [] },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: "index",
                intersect: false,
              },
              scales: {
                y: {
                  title: { display: true, text: "RSSI (dBm)" },
                  beginAtZero: false,
                },
              },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    title: function (context) {
                      return "Time: " + context[0].label;
                    },
                    label: function (context) {
                      return (
                        context.dataset.label + ": " + context.parsed.y + " dBm"
                      );
                    },
                  },
                },
              },
            },
          }
        );

        // Latency Chart
        charts.latency = new Chart(
          document.getElementById("latencyChart").getContext("2d"),
          {
            type: "line",
            data: { labels: [], datasets: [] },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: "index",
                intersect: false,
              },
              scales: {
                y: {
                  title: { display: true, text: "Latency (ms)" },
                  beginAtZero: true,
                },
              },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      return (
                        context.dataset.label + ": " + context.parsed.y + " ms"
                      );
                    },
                  },
                },
              },
            },
          }
        );

        // Packet Loss Chart
        charts.packetLoss = new Chart(
          document.getElementById("packetLossChart").getContext("2d"),
          {
            type: "line",
            data: { labels: [], datasets: [] },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: "index",
                intersect: false,
              },
              scales: {
                y: {
                  title: { display: true, text: "Packet Loss (%)" },
                  beginAtZero: true,
                  max: 100,
                },
              },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      return (
                        context.dataset.label + ": " + context.parsed.y + "%"
                      );
                    },
                  },
                },
              },
            },
          }
        );

        // Throughput Chart
        charts.throughput = new Chart(
          document.getElementById("throughputChart").getContext("2d"),
          {
            type: "line",
            data: { labels: [], datasets: [] },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: "index",
                intersect: false,
              },
              scales: {
                y: {
                  title: { display: true, text: "Throughput (KB/s)" },
                  beginAtZero: true,
                },
              },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      return (
                        context.dataset.label +
                        ": " +
                        context.parsed.y +
                        " KB/s"
                      );
                    },
                  },
                },
              },
            },
          }
        );
      }

      // Helper to update QoS display box
      function updateQoSDisplay(qos) {
        const qosDisplay = document.getElementById("qosDisplay");
        qosDisplay.textContent = `${qos}`;
        qosDisplay.className = "alert";

        switch (qos) {
          case "High":
            qosDisplay.classList.add("alert-success");
            break;
          case "Medium":
            qosDisplay.classList.add("alert-warning");
            break;
          case "Low":
            qosDisplay.classList.add("alert-danger");
            break;
          default:
            qosDisplay.classList.add("alert-secondary");
            qosDisplay.textContent = "QoS: Unknown or Unavailable";
        }
      }

      // Listen for incoming real-time data and update QoS
      /*socket.on("network_data", function (data) {
        if (data.qos) {
          updateQoSDisplay(data.qos);
        }
      });*/

      // Simulate test QoS prediction via POST request
      function requestQoSPrediction() {
        fetch("/api/data", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            node_id: "esp32_node1",
            protocol: "MQTT",
            rssi: -55,
            latency: 40,
            packets_lost: 0,
            packets_total: 100,
            throughput: 130,
          }),
        })
          .then((res) => res.json())
          .then((res) => {
            if (res.qos) {
              updateQoSDisplay(res.qos);
            }
          })
          .catch((err) => {
            console.error("QoS request failed:", err);
            updateQoSDisplay("Unknown");
          });
      }

      function updateOverviewMetrics(data = null) {
        const filteredData = data || filterData();
        if (filteredData.length === 0) {
          resetMetrics();
          return;
        }
        const nodeStatus = calculateNodeStatus(filteredData);
        updateNodeMetrics(nodeStatus);
        const averages = calculateAverageMetrics(filteredData);
        updateAverageMetrics(averages);
        updateTotalMeasurements(filteredData.length);
        updateTimeRangeDisplay();
        //requestQoSPrediction();
      }

      function calculateNodeStatus(data) {
        const nodeLastSeen = {};
        const nodeAverages = {};
        const currentTime = new Date();
        data.forEach((d) => {
          const nodeId = d.node_id;
          const timestamp = new Date(d.timestamp);

          if (!nodeLastSeen[nodeId] || timestamp > nodeLastSeen[nodeId]) {
            nodeLastSeen[nodeId] = timestamp;
          }

          if (!nodeAverages[nodeId]) {
            nodeAverages[nodeId] = {
              rssi: [],
              latency: [],
              packetLoss: [],
            };
          }
          nodeAverages[nodeId].rssi.push(d.rssi);
          nodeAverages[nodeId].latency.push(d.latency);
          const packetLoss =
            d.packets_total > 0 ? (d.packets_lost / d.packets_total) * 100 : 0;
          nodeAverages[nodeId].packetLoss.push(packetLoss);
        });
        let onlineNodes = 0;
        let warningNodes = 0;
        let offlineNodes = 0;

        Object.keys(nodeLastSeen).forEach((nodeId) => {
          const lastSeen = nodeLastSeen[nodeId];
          const timeDiff = (currentTime - lastSeen) / (1000 * 60); // minutes

          if (timeDiff > 30) {
            offlineNodes++;
          } else {
            const avgRssi =
              nodeAverages[nodeId].rssi.reduce((a, b) => a + b, 0) /
              nodeAverages[nodeId].rssi.length;
            const avgLatency =
              nodeAverages[nodeId].latency.reduce((a, b) => a + b, 0) /
              nodeAverages[nodeId].latency.length;
            const avgPacketLoss =
              nodeAverages[nodeId].packetLoss.reduce((a, b) => a + b, 0) /
              nodeAverages[nodeId].packetLoss.length;
            if (avgRssi < -70 || avgLatency > 100 || avgPacketLoss > 5) {
              warningNodes++;
            } else {
              onlineNodes++;
            }
          }
        });

        return {
          total: Object.keys(nodeLastSeen).length,
          online: onlineNodes,
          warning: warningNodes,
          offline: offlineNodes,
        };
      }

      function updateNodeMetrics(nodeStatus) {
        document.getElementById("activeNodes").textContent = nodeStatus.total;
        document.getElementById("onlineNodes").textContent = nodeStatus.online;
        document.getElementById("warningNodes").textContent =
          nodeStatus.warning;
      }

      function calculateAverageMetrics(data) {
        if (data.length === 0) return null;

        const totals = data.reduce(
          (acc, d) => {
            acc.rssi += d.rssi;
            acc.latency += d.latency;
            acc.throughput += d.throughput;

            const packetLoss =
              d.packets_total > 0
                ? (d.packets_lost / d.packets_total) * 100
                : 0;
            acc.packetLoss += packetLoss;

            return acc;
          },
          { rssi: 0, latency: 0, throughput: 0, packetLoss: 0 }
        );

        return {
          rssi: totals.rssi / data.length,
          latency: totals.latency / data.length,
          throughput: totals.throughput / data.length,
          packetLoss: totals.packetLoss / data.length,
        };
      }

      // Update average metrics display with performance indicators
      function updateAverageMetrics(averages) {
        if (!averages) return;

        // Update RSSI
        const rssiValue = averages.rssi.toFixed(1);
        document.getElementById("avgRssi").textContent = `${rssiValue} dBm`;
        updatePerformanceIndicator("rssi", averages.rssi, -30, -70, -90);

        // Update Latency
        const latencyValue = averages.latency.toFixed(1);
        document.getElementById(
          "avgLatency"
        ).textContent = `${latencyValue} ms`;
        updatePerformanceIndicator(
          "latency",
          averages.latency,
          50,
          100,
          200,
          true
        );

        // Update Packet Loss
        const packetLossValue = averages.packetLoss.toFixed(2);
        document.getElementById(
          "avgPacketLoss"
        ).textContent = `${packetLossValue}%`;
        updatePerformanceIndicator(
          "packetLoss",
          averages.packetLoss,
          1,
          5,
          10,
          true
        );

        // Update Throughput
        const throughputValue = averages.throughput.toFixed(1);
        document.getElementById(
          "avgThroughput"
        ).textContent = `${throughputValue} KB/s`;
        updatePerformanceIndicator(
          "throughput",
          averages.throughput,
          100,
          50,
          10
        );
      }

      // Update performance indicators and status text
      function updatePerformanceIndicator(
        metric,
        value,
        goodThreshold,
        warningThreshold,
        poorThreshold,
        higherIsBad = false
      ) {
        const indicator = document.getElementById(`${metric}Indicator`);
        const status = document.getElementById(`${metric}Status`);

        let level, statusText, color;

        if (higherIsBad) {
          // For metrics where higher values are bad (latency, packet loss)
          if (value <= goodThreshold) {
            level = "excellent";
            statusText = "Excellent";
            color = "#28a745";
          } else if (value <= warningThreshold) {
            level = "good";
            statusText = "Good";
            color = "#17a2b8";
          } else if (value <= poorThreshold) {
            level = "warning";
            statusText = "Warning";
            color = "#ffc107";
          } else {
            level = "poor";
            statusText = "Poor";
            color = "#dc3545";
          }
        } else {
          // For metrics where higher values are good (RSSI, throughput)
          if (value >= goodThreshold) {
            level = "excellent";
            statusText = "Excellent";
            color = "#28a745";
          } else if (value >= warningThreshold) {
            level = "good";
            statusText = "Good";
            color = "#17a2b8";
          } else if (value >= poorThreshold) {
            level = "warning";
            statusText = "Warning";
            color = "#ffc107";
          } else {
            level = "poor";
            statusText = "Poor";
            color = "#dc3545";
          }
        }

        // Update indicator
        indicator.className = `performance-indicator ${level}`;
        indicator.style.backgroundColor = color;

        // Update status text
        status.textContent = statusText;
        status.style.color = color;
      }

      // Update total measurements count
      function updateTotalMeasurements(count) {
        document.getElementById("totalMeasurements").textContent =
          count.toLocaleString();
      }

      // Update time range display
      function updateTimeRangeDisplay() {
        const timeRange = parseInt(document.getElementById("timeRange").value);
        const timeRangeSpan = document.getElementById("currentTimeRange");
        const pluralSpan = document.getElementById("timeRangePlural");

        if (timeRangeSpan && pluralSpan) {
          timeRangeSpan.textContent = timeRange;
          pluralSpan.textContent = timeRange === 1 ? "" : "s";
        }
      }

      // Reset all metrics to default values
      function resetMetrics() {
        document.getElementById("activeNodes").textContent = "0";
        document.getElementById("onlineNodes").textContent = "0";
        document.getElementById("warningNodes").textContent = "0";
        document.getElementById("avgRssi").textContent = "0 dBm";
        document.getElementById("avgLatency").textContent = "0 ms";
        document.getElementById("avgPacketLoss").textContent = "0%";
        document.getElementById("avgThroughput").textContent = "0 KB/s";
        document.getElementById("totalMeasurements").textContent = "0";

        // Reset status indicators
        ["rssi", "latency", "packetLoss", "throughput"].forEach((metric) => {
          const indicator = document.getElementById(`${metric}Indicator`);
          const status = document.getElementById(`${metric}Status`);

          if (indicator) {
            indicator.className = "performance-indicator";
            indicator.style.backgroundColor = "#6c757d";
          }

          if (status) {
            status.textContent = "No data";
            status.style.color = "#6c757d";
          }
        });
      }

      function updateProtocolLegend() {
        const legendContainer = document.getElementById("protocolLegend");
        legendContainer.innerHTML = "";

        Object.entries(protocolColors).forEach(([protocol, color]) => {
          const legendItem = document.createElement("div");
          legendItem.className = "legend-item";
          legendItem.innerHTML = `
                                <div class="legend-color" style="background-color: ${color}"></div>
                                <span>${protocol}</span>
                            `;
          legendContainer.appendChild(legendItem);
        });
      }

      function getSelectedNodes() {
        const selector = document.getElementById("nodeSelector");
        return Array.from(selector.selectedOptions).map(
          (option) => option.value
        );
      }

      function getSelectedProtocols() {
        const selector = document.getElementById("protocolSelector");
        const selected = Array.from(selector.selectedOptions).map(
          (option) => option.value
        );
        return selected.length > 0 ? selected : Object.keys(protocolColors);
      }

      function updateNodeSelector() {
        const selector = document.getElementById("nodeSelector");
        const currentSelection = getSelectedNodes();
        selector.innerHTML = "";

        const nodeIds = [...new Set(allData.map((d) => d.node_id))].sort();
        nodeIds.forEach((nodeId) => {
          const option = document.createElement("option");
          option.value = nodeId;
          option.textContent = nodeId;
          option.selected =
            currentSelection.includes(nodeId) || currentSelection.length === 0;
          selector.appendChild(option);
        });
      }

      function filterData() {
        const selectedNodes = getSelectedNodes();
        const selectedProtocols = getSelectedProtocols();
        const timeRange = parseInt(document.getElementById("timeRange").value);

        const cutoffTime = new Date(Date.now() - timeRange * 60 * 1000);

        return allData.filter((d) => {
          const dataTime = new Date(d.timestamp);
          const nodeMatch =
            selectedNodes.length === 0 || selectedNodes.includes(d.node_id);
          const protocolMatch = selectedProtocols.includes(d.protocol || "TCP");
          const timeMatch = dataTime >= cutoffTime;

          return nodeMatch && protocolMatch && timeMatch;
        });
      }

      function updateCharts() {
        const filteredData = filterData();

        // Clear existing datasets
        Object.values(charts).forEach((chart) => {
          chart.data.datasets = [];
          chart.data.labels = [];
        });

        if (filteredData.length === 0) {
          Object.values(charts).forEach((chart) => chart.update());
          updateNodeCounts(0);
          updateOverviewMetrics([]);
          return;
        }

        // Group data by node and protocol
        const groupedData = {};
        filteredData.forEach((d) => {
          const key = `${d.node_id}_${d.protocol || "TCP"}`;
          if (!groupedData[key]) {
            groupedData[key] = {
              node_id: d.node_id,
              protocol: d.protocol || "TCP",
              data: [],
            };
          }
          groupedData[key].data.push(d);
        });

        // Sort data by timestamp and limit points
        Object.values(groupedData).forEach((group) => {
          group.data.sort(
            (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
          );
          if (group.data.length > maxPoints) {
            group.data = group.data.slice(-maxPoints);
          }
        });

        // Create datasets for each chart
        let datasetIndex = 0;
        const uniqueNodes = new Set();

        Object.values(groupedData).forEach((group) => {
          const color =
            protocolColors[group.protocol] ||
            nodeColors[datasetIndex % nodeColors.length];
          const label = `${group.node_id} (${group.protocol})`;
          uniqueNodes.add(group.node_id);

          // RSSI Dataset
          charts.rssi.data.datasets.push({
            label: label,
            data: group.data.map((d) => ({
              x: new Date(d.timestamp).toLocaleTimeString(),
              y: d.rssi,
            })),
            borderColor: color,
            backgroundColor: color + "20",
            fill: false,
            tension: 0.1,
          });

          // Latency Dataset
          charts.latency.data.datasets.push({
            label: label,
            data: group.data.map((d) => ({
              x: new Date(d.timestamp).toLocaleTimeString(),
              y: d.latency,
            })),
            borderColor: color,
            backgroundColor: color + "20",
            fill: false,
            tension: 0.1,
          });

          // Packet Loss Dataset
          charts.packetLoss.data.datasets.push({
            label: label,
            data: group.data.map((d) => ({
              x: new Date(d.timestamp).toLocaleTimeString(),
              y:
                d.packets_total > 0
                  ? (d.packets_lost / d.packets_total) * 100
                  : 0,
            })),
            borderColor: color,
            backgroundColor: color + "20",
            fill: false,
            tension: 0.1,
          });

          // Throughput Dataset
          charts.throughput.data.datasets.push({
            label: label,
            data: group.data.map((d) => ({
              x: new Date(d.timestamp).toLocaleTimeString(),
              y: d.throughput,
            })),
            borderColor: color,
            backgroundColor: color + "20",
            fill: false,
            tension: 0.1,
          });

          datasetIndex++;
        });

        // Set common labels (use timestamps from first dataset)
        if (Object.values(groupedData).length > 0) {
          const firstGroup = Object.values(groupedData)[0];
          const labels = firstGroup.data.map((d) =>
            new Date(d.timestamp).toLocaleTimeString()
          );

          Object.values(charts).forEach((chart) => {
            chart.data.labels = labels;
            chart.update("none");
          });
        }

        updateNodeCounts(uniqueNodes.size);
        updateProtocolStats(filteredData);
        updateOverviewMetrics(filteredData); // Add this line at the end
      }

      function updateNodeCounts(count) {
        document.getElementById("rssiNodeCount").textContent = `${count} nodes`;
        document.getElementById(
          "latencyNodeCount"
        ).textContent = `${count} nodes`;
        document.getElementById(
          "packetLossNodeCount"
        ).textContent = `${count} nodes`;
        document.getElementById(
          "throughputNodeCount"
        ).textContent = `${count} nodes`;
      }

      function updateProtocolStats(data) {
        const statsContainer = document.getElementById("protocolStats");
        statsContainer.innerHTML = "";

        const protocolStats = {};

        data.forEach((d) => {
          const protocol = d.protocol || "TCP";
          if (!protocolStats[protocol]) {
            protocolStats[protocol] = {
              count: 0,
              avgLatency: 0,
              avgThroughput: 0,
              avgPacketLoss: 0,
              totalLatency: 0,
              totalThroughput: 0,
              totalPacketLoss: 0,
            };
          }

          protocolStats[protocol].count++;
          protocolStats[protocol].totalLatency += d.latency;
          protocolStats[protocol].totalThroughput += d.throughput;

          const packetLoss =
            d.packets_total > 0 ? (d.packets_lost / d.packets_total) * 100 : 0;
          protocolStats[protocol].totalPacketLoss += packetLoss;
        });

        // Calculate averages
        Object.keys(protocolStats).forEach((protocol) => {
          const stats = protocolStats[protocol];
          stats.avgLatency = (stats.totalLatency / stats.count).toFixed(2);
          stats.avgThroughput = (stats.totalThroughput / stats.count).toFixed(
            2
          );
          stats.avgPacketLoss = (stats.totalPacketLoss / stats.count).toFixed(
            2
          );
        });

        // Create stat cards
        Object.entries(protocolStats).forEach(([protocol, stats]) => {
          const color = protocolColors[protocol] || "#6c757d";
          const statCard = document.createElement("div");
          statCard.className = "col-md-2 mb-3";
          statCard.innerHTML = `
                                <div class="card border-0" style="border-left: 4px solid ${color} !important;">
                                    <div class="card-body p-3">
                                        <h6 class="card-title mb-1">${protocol}</h6>
                                        <small class="text-muted d-block mb-2">${stats.count} data points</small>
                                        <div class="small">
                                            <div>Latency: ${stats.avgLatency}ms</div>
                                            <div>Throughput: ${stats.avgThroughput}KB/s</div>
                                            <div>Loss: ${stats.avgPacketLoss}%</div>
                                        </div>
                                    </div>
                                </div>
                            `;
          statsContainer.appendChild(statCard);
        });
      }

      const performanceIndicatorCSS = `
      .performance-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 5px;
        background-color: #6c757d;
      }

      .performance-indicator.excellent {
        background-color: #28a745;
      }

      .performance-indicator.good {
        background-color: #17a2b8;
      }

      .performance-indicator.warning {
        background-color: #ffc107;
      }

      .performance-indicator.poor {
        background-color: #dc3545;
      }

      .metric-card {
        transition: all 0.3s ease;
        border: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      .metric-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      }

      .metric-value {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 0.25rem;
      }

      .metric-label {
        font-size: 0.875rem;
        color: #6c757d;
        margin-bottom: 0.5rem;
      }
      `;

      function addPerformanceIndicatorStyles() {
        const style = document.createElement("style");
        style.textContent = performanceIndicatorCSS;
        document.head.appendChild(style);
      }

      function updateTable(data) {
        const tableBody = document.getElementById("dataTable");

        if (data) {
          const row = document.createElement("tr");
          const packetLoss =
            data.packets_total > 0
              ? ((data.packets_lost / data.packets_total) * 100).toFixed(2)
              : "0.00";
          const time = new Date(
            data.timestamp || Date.now()
          ).toLocaleTimeString();

          row.innerHTML = `
                                <td>${data.node_id || "unknown"}</td>
                                <td><span class="badge" style="background-color: ${
                                  protocolColors[data.protocol] || "#6c757d"
                                }">${data.protocol || "TCP"}</span></td>
                                <td>${data.rssi} dBm</td>
                                <td>${data.channel}</td>
                                <td>${data.latency} ms</td>
                                <td>${packetLoss}%</td>
                                <td>${data.throughput} KB/s</td>
                                <td>${time}</td>
                            `;

          if (tableBody.children.length >= 50) {
            tableBody.removeChild(tableBody.firstChild);
          }
          tableBody.appendChild(row);
        }
      }

      function exportData() {
        const filteredData = filterData();
        if (filteredData.length === 0) {
          alert("No data to export");
          return;
        }

        const csvContent = [
          [
            "Node ID",
            "Protocol",
            "RSSI (dBm)",
            "Channel",
            "Latency (ms)",
            "Packet Loss (%)",
            "Throughput (KB/s)",
            "Timestamp",
          ].join(","),
          ...filteredData.map((d) =>
            [
              d.node_id,
              d.protocol || "TCP",
              d.rssi,
              d.channel,
              d.latency,
              d.packets_total > 0
                ? ((d.packets_lost / d.packets_total) * 100).toFixed(2)
                : "0.00",
              d.throughput,
              d.timestamp,
            ].join(",")
          ),
        ].join("\n");

        const blob = new Blob([csvContent], { type: "text/csv" });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `network_data_${new Date()
          .toISOString()
          .slice(0, 10)}.csv`;
        a.click();
        window.URL.revokeObjectURL(url);
      }

      function setupEventListeners() {
        document
          .getElementById("updateCharts")
          .addEventListener("click", updateCharts);
        document.getElementById("timeRange").addEventListener("change", () => {
          updateTimeRangeDisplay();
          loadHistoricalData();
        });
        document
          .getElementById("clearFilters")
          .addEventListener("click", () => {
            document.getElementById("nodeSelector").selectedIndex = -1;
            document.getElementById("protocolSelector").selectedIndex = -1;
            updateCharts();
          });
        document
          .getElementById("exportData")
          .addEventListener("click", exportData);
      }

      function setupWebSocket() {
        socket = io();
        socket.on("network_data", function (data) {
          if (!data.timestamp) {
            data.timestamp = new Date().toISOString();
          }
          allData.push(data);
          const cutoffTime = new Date(Date.now() - 24 * 60 * 60 * 1000);
          allData = allData.filter((d) => new Date(d.timestamp) >= cutoffTime);

          updateNodeSelector();
          updateTable(data);
          updateQoSDisplay(data.qos);
          updateOverviewMetrics();
          const selectedNodes = getSelectedNodes();
          if (
            selectedNodes.length === 0 ||
            selectedNodes.includes(data.node_id)
          ) {
            updateCharts();
          }
        });
      }

      function loadHistoricalData() {
        const timeRange = document.getElementById("timeRange").value;
        fetch(`/api/history?hours=${timeRange}`)
          .then((response) => response.json())
          .then((data) => {
            allData = data.map((d) => ({
              ...d,
              timestamp: d.timestamp || new Date().toISOString(),
            }));
            updateNodeSelector();
            updateCharts();
          })
          .catch((error) =>
            console.error("Error loading historical data:", error)
          );
      }

      function showNotification(message, type = "info", duration = 5000) {
        const notificationArea = document.getElementById("notificationArea");
        const notificationId = "notification-" + Date.now();

        const typeIcons = {
          success: "check-circle",
          warning: "exclamation-triangle",
          danger: "exclamation-circle",
          info: "info-circle",
        };

        const notificationHtml = `
                    <div id="${notificationId}" class="notification alert alert-${type} alert-dismissible fade show" role="alert">
                        <i class="fas fa-${typeIcons[type]} me-2"></i>
                        ${message}
                        <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
                    </div>
                `;

        notificationArea.insertAdjacentHTML("beforeend", notificationHtml);

        if (duration > 0) {
          setTimeout(() => {
            const notification = document.getElementById(notificationId);
            if (notification) {
              notification.classList.remove("show");
              setTimeout(() => notification.remove(), 150);
            }
          }, duration);
        }
      }

      function updateConnectionStatus(connected) {
        const statusEl = document.getElementById("connectionStatus");
        const textEl = document.getElementById("connectionText");

        if (connected) {
          statusEl.className = "status-indicator status-online";
          textEl.textContent = "Connected";
        } else {
          statusEl.className = "status-indicator status-offline";
          textEl.textContent = "Disconnected";
        }
      }

      function showLoading(show) {
        document.getElementById("loadingSpinner").style.display = show
          ? "block"
          : "none";
      }

      function generateReport() {
        const reportWindow = window.open("", "_blank");
        reportWindow.document.write(`
                    <html>
                    <head>
                        <title>Network Monitoring Report</title>
                        <style>
                            body { font-family: Arial, sans-serif; margin: 40px; }
                            .header { text-align: center; margin-bottom: 40px; }
                            .metric { margin: 20px 0; padding: 15px; border-left: 4px solid #007bff; background: #f8f9fa; }
                        </style>
                    </head>
                    <body>
                        <div class="header">
                            <h1>IoT Network Monitoring Report</h1>
                            <p>Generated on ${new Date().toLocaleString()}</p>
                        </div>
                        <div class="metric">
                            <h3>Active Nodes: ${
                              document.getElementById("activeNodes")
                                ?.textContent || "N/A"
                            }</h3>
                        </div>
                        <div class="metric">
                            <h3>Average RSSI: ${
                              document.getElementById("avgRssi")?.textContent ||
                              "N/A"
                            }</h3>
                        </div>
                        <div class="metric">
                            <h3>Average Latency: ${
                              document.getElementById("avgLatency")
                                ?.textContent || "N/A"
                            }</h3>
                        </div>
                        <div class="metric">
                            <h3>Average Packet Loss: ${
                              document.getElementById("avgPacketLoss")
                                ?.textContent || "N/A"
                            }</h3>
                        </div>
                        <p style="text-align: center; margin-top: 40px; color: #666;">
                            Report generated by Enhanced IoT Network Monitor
                        </p>
                    </body>
                    </html>
                `);
        reportWindow.document.close();
      }

      function setupKeyboardShortcuts() {
        document.addEventListener("keydown", (e) => {
          if (e.ctrlKey || e.metaKey) {
            switch (e.key) {
              case "r":
                e.preventDefault();
                loadHistoricalData();
                break;
              case "e":
                e.preventDefault();
                exportData();
                break;
              case " ":
                e.preventDefault();
                break;
            }
          }
        });
      }

      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      }

      function setupWebSocket() {
        socket = io();

        socket.on("connect", () => {
          console.log("Connected to server");
          updateConnectionStatus(true);
          showNotification("Connected to network monitor", "success");
          showLoading(false);
        });

        socket.on("disconnect", () => {
          console.log("Disconnected from server");
          updateConnectionStatus(false);
          showNotification("Disconnected from server", "warning");
        });

        socket.on("network_data", function (data) {
          if (!data.timestamp) {
            data.timestamp = new Date().toISOString();
          }

          allData.push(data);

          // Keep only recent data (last 24 hours)
          const cutoffTime = new Date(Date.now() - 24 * 60 * 60 * 1000);
          allData = allData.filter((d) => new Date(d.timestamp) >= cutoffTime);

          updateNodeSelector();
          updateTable(data);

          // Show real-time QoS label if present
          if (data.qos) {
            updateQoSDisplay(data.qos);
          }

          // Auto-update charts if no specific filters are applied
          const selectedNodes = getSelectedNodes();
          if (
            selectedNodes.length === 0 ||
            selectedNodes.includes(data.node_id)
          ) {
            updateCharts();
          }
        });

        socket.on("connect_error", (error) => {
          console.error("Socket connection error:", error);
          updateConnectionStatus(false);
          showNotification("Connection error. Retrying...", "danger");
        });
      }

      // Initialize everything
      window.addEventListener("load", function () {
        initializeCharts();
        updateProtocolLegend();
        //setupEventListeners();
        loadHistoricalData();
        addPerformanceIndicatorStyles(); // Add this line
        updateTimeRangeDisplay();
        setupEventListeners();
        setupWebSocket(); // Add this line
      });
    </script>
  </body>
</html>
